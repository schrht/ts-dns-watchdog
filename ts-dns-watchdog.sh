#!/bin/bash

# Tailscale DNS Watchdog Script
# Automatically detects and fixes DNS fight issues with MagicDNS
# Strictly based on tailscale status --json for state determination

set -euo pipefail

# ============================================================================
# Configuration Variables
# ============================================================================

# Check interval (seconds)
CHECK_INTERVAL="${CHECK_INTERVAL:-30}"

# Backup file path
BACKUP_FILE="/etc/resolv.conf.tailscale.backup"

# Tailscale resolv.conf marker (for identifying Tailscale-generated files)
TAILSCALE_MARKER="file generated by tailscale"

# Wait time after soft fix (seconds)
SOFT_FIX_WAIT=2

# Wait time after hard fix (restart) (seconds)
HARD_FIX_WAIT=10

# Log identifier
SCRIPT_NAME="ts-dns-watchdog"

# Hard fix retry configuration
HARD_FIX_RETRY_BASE=60          # Base retry interval (seconds)
HARD_FIX_RETRY_MAX=3600         # Maximum retry interval (1 hour)
HARD_FIX_FAILURE_COUNT=0        # Track consecutive hard fix failures

# ============================================================================
# Utility Functions
# ============================================================================

# Log output function
log_message() {
    local level="$1"
    shift
    local message="$*"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    # Map script log levels to systemd priority numbers
    # systemd priorities: 0=emerg, 1=alert, 2=crit, 3=err, 4=warning, 5=notice, 6=info, 7=debug
    local sysd_priority_num
    local sysd_priority_name
    case "$level" in
        debug)   sysd_priority_num=7; sysd_priority_name="debug" ;;
        info)    sysd_priority_num=6; sysd_priority_name="info" ;;
        notice)  sysd_priority_num=5; sysd_priority_name="notice" ;;
        warning) sysd_priority_num=4; sysd_priority_name="warning" ;;
        error)   sysd_priority_num=3; sysd_priority_name="err" ;;
        *)       sysd_priority_num=6; sysd_priority_name="info" ;;
    esac
    
    # Format message with priority for display
    # Use systemd log format: <priority>message
    # This format allows systemd to recognize priority while using main process PID
    # Output to stderr, which systemd captures via StandardError=journal
    echo "<$sysd_priority_num>[$sysd_priority_name] $message" >&2
}

# Get tailscale status --json
get_tailscale_status() {
    local status_output
    if ! status_output=$(tailscale status --json 2>&1); then
        log_message "error" "Failed to get tailscale status: $status_output"
        return 1
    fi
    
    echo "$status_output"
}

# Determine if Tailscale is in Running state
# Return value: 0=Running, 1=Not Running
is_tailscale_running() {
    local status_json
    if ! status_json=$(get_tailscale_status); then
        return 1
    fi
    
    local backend_state
    if ! backend_state=$(echo "$status_json" | jq -r '.BackendState // "Unknown"' 2>/dev/null); then
        log_message "error" "Failed to parse BackendState from status JSON"
        return 1
    fi
    
    if [[ "$backend_state" == "Running" ]]; then
        return 0
    else
        log_message "debug" "Tailscale BackendState is '$backend_state', not Running"
        return 1
    fi
}

# Determine if DNS fight exists
# Return value: 0=DNS fight exists, 1=No DNS fight
has_dns_fight() {
    local status_json
    if ! status_json=$(get_tailscale_status); then
        # When unable to get status, conservatively assume no DNS fight (avoid misoperations)
        return 1
    fi
    
    local health
    if ! health=$(echo "$status_json" | jq -r '.Health // ""' 2>/dev/null); then
        log_message "error" "Failed to parse Health from status JSON"
        return 1
    fi
    
    # Check if Health field contains "System DNS config not ideal"
    if echo "$health" | grep -qi "System DNS config not ideal"; then
        return 0
    else
        return 1
    fi
}

# Determine if /etc/resolv.conf is a Tailscale-generated file
# Return value: 0=Tailscale-generated, 1=Not Tailscale-generated
is_tailscale_resolv() {
    if [[ ! -f /etc/resolv.conf ]]; then
        return 1
    fi
    
    if grep -qi "$TAILSCALE_MARKER" /etc/resolv.conf 2>/dev/null; then
        return 0
    else
        return 1
    fi
}

# Generate/update resolv.conf backup
# Only execute when conditions are met: Running + no DNS fight + Tailscale-generated file
backup_resolv_conf() {
    # Check if backup conditions are met
    if ! is_tailscale_running; then
        log_message "debug" "Skipping backup: Tailscale not Running"
        return 0
    fi
    
    if has_dns_fight; then
        log_message "debug" "Skipping backup: DNS fight detected"
        return 0
    fi
    
    if ! is_tailscale_resolv; then
        log_message "debug" "Skipping backup: resolv.conf is not Tailscale-generated"
        return 0
    fi
    
    # Check if backup needs updating (if content changed)
    if [[ -f "$BACKUP_FILE" ]]; then
        if cmp -s /etc/resolv.conf "$BACKUP_FILE" 2>/dev/null; then
            log_message "debug" "Backup already up-to-date"
            return 0
        fi
    fi
    
    # Create/update backup
    if cp /etc/resolv.conf "$BACKUP_FILE" 2>/dev/null; then
        log_message "info" "Backed up resolv.conf to $BACKUP_FILE"
        return 0
    else
        log_message "error" "Failed to backup resolv.conf (may need root privileges)"
        return 1
    fi
}

# Soft fix: Overwrite current configuration with backed up resolv.conf
# Return value: 0=Success, 1=Failure
soft_fix_resolv_conf() {
    if [[ ! -f "$BACKUP_FILE" ]]; then
        log_message "warning" "Cannot perform soft fix: backup file not found"
        return 1
    fi
    
    log_message "info" "Attempting soft fix: restoring resolv.conf from backup"
    
    if cp "$BACKUP_FILE" /etc/resolv.conf 2>/dev/null; then
        log_message "info" "Soft fix: restored resolv.conf from backup"
        
        # Wait briefly for Tailscale to detect changes
        sleep "$SOFT_FIX_WAIT"
        
        # Check again if DNS fight has disappeared
        if ! has_dns_fight; then
            log_message "info" "Soft fix successful: DNS fight resolved"
            return 0
        else
            log_message "warning" "Soft fix failed: DNS fight still present"
            return 1
        fi
    else
        log_message "error" "Soft fix failed: cannot restore resolv.conf (may need root privileges)"
        return 1
    fi
}

# Hard fix: Restart tailscaled service
# Return value: 0=Success and DNS fight disappeared, 1=Failure or DNS fight still present
hard_fix_tailscaled() {
    log_message "info" "Attempting hard fix: restarting tailscaled service"
    
    # Check if systemd is available
    if ! command -v systemctl >/dev/null 2>&1; then
        log_message "error" "Hard fix failed: systemctl not available"
        return 1
    fi
    
    # Restart tailscaled
    local restart_result
    if restart_result=$(systemctl restart tailscaled 2>&1); then
        log_message "info" "Hard fix: tailscaled service restarted"
    else
        log_message "error" "Hard fix failed: cannot restart tailscaled: $restart_result"
        return 1
    fi
    
    # Force wait for specified time
    log_message "info" "Waiting ${HARD_FIX_WAIT}s for tailscaled to stabilize"
    sleep "$HARD_FIX_WAIT"
    
    # Check if Running
    if ! is_tailscale_running; then
        log_message "error" "Hard fix: tailscaled is not Running after restart"
        return 1
    fi
    
    # Check if DNS fight has disappeared
    if ! has_dns_fight; then
        log_message "info" "Hard fix successful: DNS fight resolved after restart"
        return 0
    else
        log_message "warning" "Hard fix: DNS fight still present after restart"
        return 1
    fi
}

# Script startup initialization: Delete old backups
initialize() {
    log_message "info" "Initializing watchdog: removing any existing backup"
    
    if [[ -f "$BACKUP_FILE" ]]; then
        rm -f "$BACKUP_FILE"
        log_message "info" "Removed existing backup file"
    fi
}

# Calculate retry interval based on failure count (exponential backoff)
# Return: retry interval in seconds
calculate_retry_interval() {
    local count=$1
    local interval
    
    # Exponential backoff: base * 2^(count-1), capped at max
    # First failure: 60s, second: 120s, third: 240s, etc., max 3600s
    if [[ $count -le 0 ]]; then
        interval=$HARD_FIX_RETRY_BASE
    else
        # Calculate 2^(count-1) using bit shift: 1 << (count-1)
        local multiplier=$((1 << (count - 1)))
        interval=$((HARD_FIX_RETRY_BASE * multiplier))
        
        # Cap at maximum
        if [[ $interval -gt $HARD_FIX_RETRY_MAX ]]; then
            interval=$HARD_FIX_RETRY_MAX
        fi
    fi
    
    echo $interval
}

# ============================================================================
# Main Loop
# ============================================================================

main_loop() {
    log_message "info" "Starting Tailscale DNS Watchdog (check interval: ${CHECK_INTERVAL}s)"
    
    # Initialize: Delete old backups
    initialize
    
    while true; do
        # Check if Tailscale is Running
        if ! is_tailscale_running; then
            log_message "debug" "Tailscale not Running, skipping check"
            HARD_FIX_FAILURE_COUNT=0
            sleep "$CHECK_INTERVAL"
            continue
        fi
        
        # Try to update backup (if conditions are met)
        backup_resolv_conf
        
        # Check if DNS fight exists
        if ! has_dns_fight; then
            log_message "debug" "No DNS fight detected, system healthy"
            HARD_FIX_FAILURE_COUNT=0
            sleep "$CHECK_INTERVAL"
            continue
        fi
        
        # DNS fight detected - attempt fixes
        log_message "warning" "DNS fight detected: System DNS config not ideal"
        
        # Attempt soft fix
        if soft_fix_resolv_conf; then
            log_message "info" "DNS fight resolved via soft fix"
            HARD_FIX_FAILURE_COUNT=0
            sleep "$CHECK_INTERVAL"
            continue
        fi
        
        # Soft fix failed, attempt hard fix
        log_message "warning" "Soft fix failed, attempting hard fix"
        if hard_fix_tailscaled; then
            log_message "info" "DNS fight resolved via hard fix"
            HARD_FIX_FAILURE_COUNT=0
            sleep "$CHECK_INTERVAL"
            continue
        fi
        
        # Both fixes failed - use exponential backoff
        ((HARD_FIX_FAILURE_COUNT++))
        local retry_interval=$(calculate_retry_interval $HARD_FIX_FAILURE_COUNT)
        log_message "error" "Both soft and hard fixes failed (consecutive failures: $HARD_FIX_FAILURE_COUNT, retry in ${retry_interval}s)"
        sleep "$retry_interval"
    done
}

# ============================================================================
# Entry Point
# ============================================================================

# Check dependencies
if ! command -v tailscale >/dev/null 2>&1; then
    log_message "error" "tailscale command not found"
    exit 1
fi

if ! command -v jq >/dev/null 2>&1; then
    log_message "error" "jq command not found (required for JSON parsing)"
    exit 1
fi

# Check if running as root (needed to modify /etc/resolv.conf)
if [[ $EUID -ne 0 ]]; then
    log_message "warning" "Not running as root, some operations may fail"
fi

# Run main loop
main_loop

